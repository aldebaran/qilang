/*
** Author(s):
**  - Cedric GESTES <gestes@aldebaran-robotics.com>
**
** Copyright (C) 2014 Aldebaran Robotics
*/

#include <iostream>
#include <qi/log.hpp>
#include <qilang/node.hpp>
#include <qilang/formatter.hpp>
#include <qi/os.hpp>
#include "formatter_p.hpp"
#include <boost/uuid/random_generator.hpp>
#include <boost/uuid/uuid_io.hpp>

qiLogCategory("qigen.hppinterface");

namespace qilang {

class QiLangGenObjectDef : public NodeVisitor, public NodeFormatter {
public:
  std::string format(const NodePtrVector& node) {
    formatHeader();
    for (int i = 0; i < node.size(); ++i) {
      if (!node.at(i))
        throw std::runtime_error("Invalid Node");
      try {
        node.at(i)->accept(this);
      } catch (const std::exception&e) {
        qiLogWarning() << "Error while formating: " << e.what();
      }
    }
    formatFooter();
    return out().str();
  }

  std::string format(const NodePtr& node) {
    if (!node)
      throw std::runtime_error("Invalid Node");
    formatHeader();
    node->accept(this);
    formatFooter();
    return out().str();
  }

  void formatHeader() {
    indent() << "/* File Generated by qic" << std::endl;
    indent() << "**" << std::endl;
    indent() << "*/" << std::endl;
    indent() << "#pragma once" << std::endl;
    boost::uuids::uuid u = boost::uuids::random_generator()();
    std::string uuid = boost::uuids::to_string(u);
    indent() << "#ifndef " << uuid << std::endl;
    indent() << "#define " << uuid << std::endl;
    indent() << std::endl;
  }

  void formatFooter() {
    out() << std::endl;
    indent() << "#endif" << std::endl;
  }

protected:
  void visit(PackageNode* node) {
    throw std::runtime_error("unimplemented");
  }
  void visit(ImportNode* node) {
    throw std::runtime_error("unimplemented");
  }

  void visit(IntConstNode *node) {
    out() << node->value;
  }
  void visit(FloatConstNode *node) {
    out() << node->value;
  }
  void visit(StringConstNode *node) {
    out() << node->value;
  }
  void visit(ListConstNode* node) {
    out() << "[" << "FAIL" << "]";
  }
  void visit(DictConstNode* node) {
    out() << "{" << "FAIL" << "}";
  }
  void visit(SymbolNode* node) {
    out() << node->name;
  }
  void visit(BinaryOpNode *node) {
    throw std::runtime_error("unimplemented");
  }
  void visit(UnaryOpNode *node) {
    throw std::runtime_error("unimplemented");
  }
  void visit(VarNode *node) {
    throw std::runtime_error("unimplemented");
  }
  void visit(ExprNode *node) {
    throw std::runtime_error("unimplemented");
  }

  //indented block
  void scopedDecl(const std::vector<qilang::NodePtr>& vec) {
    ScopedIndent _(_indent);
    for (unsigned int i = 0; i < vec.size(); ++i) {
      vec[i]->accept(this);
    }
  }
  void visit(ObjectNode *node) {
    throw std::runtime_error("unimplemented");
  }
  void visit(PropertyNode *node) {
    throw std::runtime_error("unimplemented");
  }
  void visit(AtNode* node) {
    throw std::runtime_error("unimplemented");
  }

  void visit(InterfaceDeclNode* node) {
    indent() << "class " << node->name << " {" << std::endl;
    indent() << "public:" << std::endl;
    scopedDecl(node->values);
    indent() << "};" << std::endl << std::endl;
  }

  void visit(FnDeclNode* node) {
    indent() << node->ret << " " << node->name << "(";
    for (unsigned int i = 0; i < node->args.size(); ++i) {
      out() << node->args[i];
      if (i+1 < node->args.size()) {
        out() << ", ";
      }
    }
    out() << ");" << std::endl;
  }

  void visit(InDeclNode* node) {
    indent() << "// slot" << std::endl;
    indent() << "void " << node->name << "(";
    for (unsigned int i = 0; i < node->args.size(); ++i) {
      out() << node->args[i];
      if (i+1 < node->args.size()) {
        out() << ", ";
      }
    }
    out() << ");" << std::endl;
  }
  void visit(OutDeclNode* node) {
    indent() << "qi::Signal<";
    for (unsigned int i = 0; i < node->args.size(); ++i) {
      out() << node->args[i];
      if (i+1 < node->args.size()) {
        out() << ", ";
      }
    }
    out() << "> " << node->name << ";" << std::endl;
  }
  void visit(PropDeclNode* node) {
    indent() << "qi::Property<";
    for (unsigned int i = 0; i < node->args.size(); ++i) {
      out() << node->args[i];
      if (i+1 < node->args.size()) {
        out() << ", ";
      }
    }
    out() << "> " << node->name << ";" << std::endl;
  }

  void visit(StructNode* node) {
    indent() << "struct " << node->name << " {" << std::endl;
    scopedDecl(node->values);
    indent() << "};" << std::endl << std::endl;
  }

  void visit(VarDefNode* node) {
    if (node->type)
      indent() << node->type << " " << node->name;
    else
      indent() << "qi::AnyValue " << node->name;
    out() << " = " << node->value << ";" << std::endl;
  }

  void visit(ConstDefNode* node) {
    indent() << "const ";
    if (node->type)
      out() << node->type << " " << node->name;
    else
      out() << "qi::AnyValue " << node->name;
    out() << " = ";
    node->value->accept(this);
    out() << ";" << std::endl;
  }

};

  std::string genCppObjectInterface(const NodePtr& node) {
    return QiLangGenObjectDef().format(node);
  }

  std::string genCppObjectInterface(const NodePtrVector& nodes) {
    return QiLangGenObjectDef().format(nodes);
  }
}
