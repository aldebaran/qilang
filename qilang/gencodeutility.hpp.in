@QILANG_COMMON_GEN_BEGIN@
#ifndef QILANG_COMMON_CODE_FOR_QICC_GENERATED_CODE_GUARD // Do NOT use pragma once: this code is injected at generation-time in qicc generated code.
#define QILANG_COMMON_CODE_FOR_QICC_GENERATED_CODE_GUARD // TODO: use pragma once instead once this code is properly included by qicc generated code.
//Copyright (C) 2020 Softbank Robotics Robotics

/////////////////////////////////////////////////////////////////////////
// This file contains common code used by code generated by qicc.
/////////////////////////////////////////////////////////////////////////

#include <utility>
#include <type_traits>
#include <memory>
#include <sstream>

#include <boost/shared_ptr.hpp>

#include <qi/assert.hpp>
#include <qi/async.hpp>
#include <qi/trackable.hpp>
#include <qi/actor.hpp>

namespace qilang {
namespace detail {

  template<typename T>
  using inheritsActor = std::is_base_of<qi::Actor, T>;

  template<typename T>
  using inheritsTrackable = std::is_base_of<qi::Trackable<T>, T>;

  // boost::shared_ptr<T> Ptr
  // T inherits qi::Actor
  // Procedure<R()> F
  template<typename Ptr, typename F>
  auto callInStrand(Ptr&& actor, F&& func)
    -> decltype(std::forward<Ptr>(actor)->async(std::forward<F>(func))) // TODO: remove if C++ > 11
  {
    return std::forward<Ptr>(actor)->async(std::forward<F>(func));
  }

  // (boost::weak_ptr<T> || boost::shared_ptr<T>) Ptr
  // T inherits qi::Trackable<T>
  // Procedure<R()> F
  template<typename R, typename Ptr, typename F>
  auto track(Ptr&& trackable, F&& func)
    -> decltype(qi::track(boost::function<R()>{ std::forward<F>(func) }, // TODO: remove if C++ > 11
                          std::forward<Ptr>(trackable)))
  {
    // We use `boost::function` here because `qi::track()` requires it (unfortunately).
    return qi::track(boost::function<R()>{ std::forward<F>(func) },
                     std::forward<Ptr>(trackable));
  }

  // Inheriting neither `qi::Actor` nor `qi::Trackable`, we track the lifetime of the object through a weak pointer.
  // @see `safeMemberAsync()`
  // boost::shared_ptr<T> Ptr
  // Procedure<R()> F
  template<typename R, typename T, typename F, typename Ptr
          , typename std::enable_if< !inheritsActor<T>::value
                                  && !inheritsTrackable<T>::value
                                   , bool>::type = true
          >
  auto safeMemberAsyncImpl(F&& func, const Ptr& ptr)
    -> qi::Future<R>
  {
    QI_ASSERT_NOT_NULL(ptr);
    using boost::weak_ptr;
    auto maybePtr = weak_ptr<T>(ptr);
    return qi::async([=]() mutable {
      if (auto ptr = maybePtr.lock())
      {
        return std::move(func)();
      }
      else
      {
        std::ostringstream message;
        message << "Object of type `"
                << typeid(typename std::decay<Ptr>::type).name()
                << "` was destroyed before scheduled async call to `"
                << typeid(typename std::decay<F>::type).name()
                << "` was executed.";
        throw std::runtime_error(message.str());
      }
    });
  }

  // Inheriting `qi::Actor`, just use the internal strand directly.
  // @see `safeMemberAsync()`
  // boost::shared_ptr<T> Ptr
  // Procedure<R()> F
  template<typename R, typename T, typename F, typename Ptr
          , typename std::enable_if< inheritsActor<T>::value
                                  && !inheritsTrackable<T>::value
                                   , bool>::type = true
          >
  auto safeMemberAsyncImpl(F&& func, Ptr&& ptr)
    -> qi::Future<R>
  {
    QI_ASSERT_NOT_NULL(ptr);
    return qilang::detail::callInStrand(std::forward<Ptr>(ptr), std::forward<F>(func));
  }

  // Inheriting `qi::Trackable<T>`, wrap the call with `qi::track()` and let `qi::async()` execute the call on the threadpool.
  // @see `safeMemberAsync()`
  // boost::shared_ptr<T> Ptr
  // Procedure<R()> F
  template<typename R, typename T, typename F, typename Ptr
          , typename std::enable_if< inheritsTrackable<T>::value
                                  && !inheritsActor<T>::value
                                   , bool>::type = true
          >
   auto safeMemberAsyncImpl(F&& func, const Ptr& ptr)
    -> qi::Future<R>
  {
    QI_ASSERT_NOT_NULL(ptr);
    return qi::async(qilang::detail::track<R>(ptr->weakPtr(), std::forward<F>(func)));
  }

  // Inheriting both `qi::Actor` and `qi::Trackable<T>`, wraps the call with `qi::track()` and uses `qi::Actor::async()`.
  // @see `safeMemberAsync()`
  // boost::shared_ptr<T> Ptr
  // Procedure<R()> F
  template<typename R, typename T, typename F, typename Ptr
          , typename std::enable_if< inheritsTrackable<T>::value
                                  && inheritsActor<T>::value
                                   , bool>::type = true
          >
   auto safeMemberAsyncImpl(F&& func, const Ptr& ptr)
    -> qi::Future<R>
  {
    QI_ASSERT_NOT_NULL(ptr);
    return qilang::detail::callInStrand(ptr,
              qilang::detail::track<R>(ptr->weakPtr(), std::forward<F>(func)));
  }

  // Async call to a member function with guarantee that the object is alive while calling.
  // Internal behavior depends on the type:
  //  - inheriting `qi::Actor` only: call will be done through the actor's strand (thread-safe);
  //  - inheriting `qi::Trackable` only: call will be tracked before being passed to `qi::async()`
  //    (thread-safety depends on the callee);
  //  - inheriting both `qi::Actor` and `qi::Trackable`: call will be tracked before being passed
  //    executed through `qi::Actor::async()` (thread-safe)
  //  - none of the previous options: we still have a shared pointer to `this` so we track
  //    the object's lifetime and call the member if alive (thread-safety depends on the callee).
  //    This is similar to the implementation type inheriting `qi::Trackable`, except we rely
  //    on the shared pointer we own instead of `qi::Trackable`'s tooling.
  //
  // @remark Why not using directly `qi::async()`, `qi::bind()` or other alternatives instead?
  //         Because we want to handle the case where the type is neither inheriting `qi::Actor` nor `qi::Trackable`.
  //         In this case we protect the call by tracking the lifetime of the object (as if it were a qi::Trackable)
  //         and call its member through qi::async().
  //         We can only do this because Ptr must be a shared pointer.
  //         This behavior is useful in code generated by qilang but not in general, so it's kept in internal details.
  //
  // @param func    Function that will call the member function of ptr.
  //                Taking first the pointer to the object to call, followed by the rest of the call arguments.
  //                Must return the value of the member function call.
  // @param ptr     Shared pointer to the object whose member we want to call.
  // @param args    Arguments passed to the call of the member of `ptr`.
  //
  // boost::shared_ptr<T> Ptr
  // Procedure<R(Ptr, Args...)> F
  template<typename R, typename T, typename F, typename Ptr, typename... Args>
  auto safeMemberAsync(F&& func, Ptr&& ptr, Args&&... args)
    -> qi::Future<R>
  {
    QI_ASSERT_NOT_NULL(ptr);
    // We use a lambda instead of `std/boost::bind()` to help with debugging (limits obfuscation of the call stack).
    return safeMemberAsyncImpl<R, T>([=]() mutable {
        return std::forward<F>(func)(std::forward<Ptr>(ptr), std::move(args)...);
      }, std::forward<Ptr>(ptr));
  }


}
}
#endif // QILANG_COMMON_CODE_FOR_QICC_GENERATED_CODE_GUARD
@QILANG_COMMON_GEN_END@
